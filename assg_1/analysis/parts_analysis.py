import maze_generation.maze_gen as mg
import a_search_algos.repeated_a_star as search
import a_search_algos.adaptive_a_star as adaptive
import time
import os

def analysis_q2(num_mazes = 50):
    """
    Used to easily compare the number of expanded cells when prioritizing largest g value and smallest g value. 
    Params:
        num_mazes : Default of all 50 mazes generated by our code. For quicker run time, an int can be passed and it will compare mazes #1 up to int
    """
    # Ensure mazes exist or generate them
    # Compare the results of breaking Repeated foward A* ties by smallest g values vs largest g values
    results = []

    print(f"Testing Forward A* tie breaker based on cells expanded using {num_mazes} mazes...")
    print(f"{'Maze':<10} | {'Cells expanded by largest g'} | {'Cells expanded by Smallest g'} | {'Large Time':<10} | {'Small Time':<10} | {'Status'}")
    print("-" * 106)

    for i in range(1, num_mazes + 1):
        maze_name = f"maze{i}"
        
        # Check if maze exists, if not create it
        try:
            maze_list = mg.retrieve_maze(maze_name)
            # CAUTION: retrieve_maze returns a list of strings
            # a_search expects a 2D list/array or handles list of strings? 
            # let's check a_search.py knowledge_map: 
            # map = [[' ' for _ in range(len(true_map))] for _ in range(len(true_map))]
            # valid if true_map is list of strings too.
        except FileNotFoundError:
            print(f"Generating {maze_name}...")
            maze_dict = mg.create_maze(print=False, SEED=i)
            mg.save_maze(maze_dict, f"{maze_name}.txt")
            # retrieve again to get the list format expected by a_search if it relies on that
            maze_list = mg.retrieve_maze(maze_name)

        # Convert list of strings to list of lists if needed, or dict?
        # a_search.py functions mostly assume list of lists or similar for indexing [x][y]
        # BUT strings are not mutable. a_search definitely mutates `known_map`.
        # `true_map` is only read. `true_map[x][y]` works for list of strings.
        # So passing list of strings as `true_map` is fine.
        
        start = mg.find_cell(maze_list, search.START)
        goal = mg.find_cell(maze_list, search.GOAL)
        
        # Run Repeated Forward A*
        t0 = time.time()
        # sign=1 means break ties towards smaller g (default/favored usually? instruction says larger g)
        # Instruction: "break ties among cells with the same f-value in favor of cells with larger g-values"
        # Larger g-value = Closer to goal (usually).
        # In the heap, we pop smallest. 
        # priority = C * f - g  => larger g gives smaller priority => popped first.
        # So we want `sign * g` to be negative for larger g. 
        # So sign should be -1.
        # Let's verify a_search.py logic:
        # priority = CONSTANT * f_cost + (sign * g_value)
        # if sign is -1: larger g => smaller priority => popped earlier. CORRECT.
        
        forward_largest_g, forward_largest_g_exp = search.repeated_forward_a_star(start, goal, maze_list, -1)
        t1 = time.time()
        largest_g_time = t1 - t0

        # Run Repeated Backward A*
        t0 = time.time()
        forward_smallest_g, forward_smallest_g_exp = search.repeated_forward_a_star(start, goal, maze_list, 1)
        t1 = time.time()
        smallest_g_time = t1 - t0
        
        status = "OK"
        if isinstance(forward_largest_g, str) or isinstance(forward_smallest_g, str):
            status = "Fail"
        elif len(forward_largest_g) != len(forward_smallest_g):
             # Path lengths might differ if one finds optimal and other doesn't? 
             # Repeated A* on static grid should find optimal if A* is optimal?
             # Actually Repeated A* with unobserved obstacles is not guaranteed optimal path *traversal* cost,
             # but the final path on the map... wait.
             # The implementations return the path taken.
             # They might differ.
             if abs(len(forward_largest_g) - len(forward_smallest_g)) > 0:
                 status = "DiffLen"
                 status = f"Start:{start} | End:{goal} | Large G:{len(forward_largest_g)} | Small G:{len(forward_smallest_g)}"

        results.append({
            "Maze": maze_name,
            "Fwd_Largest_g": forward_largest_g_exp,
            "Fwd_Smallest_g": forward_smallest_g_exp,
            "Largest_g_time": largest_g_time,
            "Smallest_g_time": smallest_g_time
        })

        print(f"{maze_name:<10} | {forward_largest_g_exp:<27.2f} | {forward_smallest_g_exp:<28.2f} | {largest_g_time:<10.4f} | {smallest_g_time:<10.4f} | {status}")

    # Calculate averages
    avg_fwd_large = sum(r["Fwd_Largest_g"] for r in results) / num_mazes
    avg_fwd_small = sum(r["Fwd_Smallest_g"] for r in results) / num_mazes
    avg_largest_time = sum(r["Largest_g_time"] for r in results) / num_mazes
    avg_smallest_time = sum(r["Smallest_g_time"] for r in results) / num_mazes
    
    print("-" * 106)
    print(f"{'Average':<10} | {avg_fwd_large:<27.2f} | {avg_fwd_small:<28.2f} | {avg_largest_time:<10.4f} | {avg_smallest_time:<10.4f} |")

    #Calculate how better prioritizing by large is in terms of % improvement
    large_cell_improvement = (avg_fwd_large - avg_fwd_small)/avg_fwd_small
    large_time_improvement = (avg_largest_time - avg_smallest_time)/avg_smallest_time
    #% shown will be negative, which means a reduction in time (good)
    print(f"{'% Improved':<10} | {large_cell_improvement:<27.2f} | {'-':<28} | {large_time_improvement:<10.4f} | {'-':<10} |")

def analysis_q3(num_mazes = 50):
    # Ensure mazes exist or generate them
    # The assignment likely asks to generate 50 gridworlds
    # We will generate them and save them as maze1..maze50 if they don't exist
    
    results = []

    print(f"Running Forward vs Backward Repeated A* experiments on {num_mazes} mazes...")
    print(f"{'Maze':<10} | {'Fwd Exp':<10} | {'Bwd Exp':<10} | {'Fwd Time':<10} | {'Bwd Time':<10} | {'Status'}")
    print("-" * 75)

    for i in range(1, num_mazes + 1):
        maze_name = f"maze{i}"
        
        # Check if maze exists, if not create it
        try:
            maze_list = mg.retrieve_maze(maze_name)
            # CAUTION: retrieve_maze returns a list of strings
            # a_search expects a 2D list/array or handles list of strings? 
            # let's check a_search.py knowledge_map: 
            # map = [[' ' for _ in range(len(true_map))] for _ in range(len(true_map))]
            # valid if true_map is list of strings too.
        except FileNotFoundError:
            print(f"Generating {maze_name}...")
            maze_dict = mg.create_maze(print=False, SEED=i)
            mg.save_maze(maze_dict, f"{maze_name}.txt")
            # retrieve again to get the list format expected by a_search if it relies on that
            maze_list = mg.retrieve_maze(maze_name)

        # Convert list of strings to list of lists if needed, or dict?
        # a_search.py functions mostly assume list of lists or similar for indexing [x][y]
        # BUT strings are not mutable. a_search definitely mutates `known_map`.
        # `true_map` is only read. `true_map[x][y]` works for list of strings.
        # So passing list of strings as `true_map` is fine.
        
        start = mg.find_cell(maze_list, search.START)
        goal = mg.find_cell(maze_list, search.GOAL)
        
        # Run Repeated Forward A*
        t0 = time.time()
        # sign=1 means break ties towards smaller g (default/favored usually? instruction says larger g)
        # Instruction: "break ties among cells with the same f-value in favor of cells with larger g-values"
        # Larger g-value = Closer to goal (usually).
        # In the heap, we pop smallest. 
        # priority = C * f - g  => larger g gives smaller priority => popped first.
        # So we want `sign * g` to be negative for larger g. 
        # So sign should be -1.
        # Let's verify a_search.py logic:
        # priority = CONSTANT * f_cost + (sign * g_value)
        # if sign is -1: larger g => smaller priority => popped earlier. CORRECT.
        
        fwd_path, fwd_exp = search.repeated_forward_a_star(start, goal, maze_list, -1)
        t1 = time.time()
        fwd_time = t1 - t0

        # Run Repeated Backward A*
        t0 = time.time()
        bwd_path, bwd_exp = search.repeated_backward_a_star(start, goal, maze_list, -1)
        t1 = time.time()
        bwd_time = t1 - t0
        
        status = "OK"
        if isinstance(fwd_path, str) or isinstance(bwd_path, str):
            status = "Fail"
        elif len(fwd_path) != len(bwd_path):
             # Path lengths might differ if one finds optimal and other doesn't? 
             # Repeated A* on static grid should find optimal if A* is optimal?
             # Actually Repeated A* with unobserved obstacles is not guaranteed optimal path *traversal* cost,
             # but the final path on the map... wait.
             # The implementations return the path taken.
             # They might differ.
             if abs(len(fwd_path) - len(bwd_path)) > 0:
                 status = "DiffLen"

        results.append({
            "Maze": maze_name,
            "Fwd_Exp": fwd_exp,
            "Bwd_Exp": bwd_exp,
            "Fwd_Time": fwd_time,
            "Bwd_Time": bwd_time
        })

        print(f"{maze_name:<10} | {fwd_exp:<10} | {bwd_exp:<10} | {fwd_time:<10.4f} | {bwd_time:<10.4f} | {status}")

    # Calculate averages
    avg_fwd = sum(r["Fwd_Exp"] for r in results) / num_mazes
    avg_bwd = sum(r["Bwd_Exp"] for r in results) / num_mazes
    
    print("-" * 75)
    print(f"{'Average':<10} | {avg_fwd:<10.1f} | {avg_bwd:<10.1f} | {'-':<10} | {'-':<10} |")

if __name__ == "__main__":
    analysis_q3()


def analysis_q5(num_mazes = 50):
    """
    Used to easily compare the number of expanded cells between repeated forward A* using large g values and adaptive A* using heuristics. 
    Params:
        num_mazes : Default of all 50 mazes generated by our code. For quicker run time, an int can be passed and it will compare mazes #1 up to int
    """
    # Ensure mazes exist or generate them
    # Compare the results of breaking Repeated foward A* ties by smallest g values vs largest g values
    results = []

    print(f"Testing Forward A* and Adaptive A* on cells expanded using {num_mazes} mazes...")
    print(f"{'Maze':<10} | {'Cells expanded Forward A*':<27} | {'Cells expanded by Adaptive A*':<28} | {'Forward Time':<10} | {'Adaptive Time':<10} | {'Status'}")
    print("-" * 112)

    for i in range(1, num_mazes + 1):
        maze_name = f"maze{i}"
        
        # Check if maze exists, if not create it
        try:
            maze_list = mg.retrieve_maze(maze_name)
            # CAUTION: retrieve_maze returns a list of strings
            # a_search expects a 2D list/array or handles list of strings? 
            # let's check a_search.py knowledge_map: 
            # map = [[' ' for _ in range(len(true_map))] for _ in range(len(true_map))]
            # valid if true_map is list of strings too.
        except FileNotFoundError:
            print(f"Generating {maze_name}...")
            maze_dict = mg.create_maze(print=False, SEED=i)
            mg.save_maze(maze_dict, f"{maze_name}.txt")
            # retrieve again to get the list format expected by a_search if it relies on that
            maze_list = mg.retrieve_maze(maze_name)

        # Convert list of strings to list of lists if needed, or dict?
        # a_search.py functions mostly assume list of lists or similar for indexing [x][y]
        # BUT strings are not mutable. a_search definitely mutates `known_map`.
        # `true_map` is only read. `true_map[x][y]` works for list of strings.
        # So passing list of strings as `true_map` is fine.
        
        start = mg.find_cell(maze_list, search.START)
        goal = mg.find_cell(maze_list, search.GOAL)
        
        # Run Repeated Forward A*
        t0 = time.time()
        forward_largest_g, forward_largest_g_exp = search.repeated_forward_a_star(start, goal, maze_list, -1)
        t1 = time.time()
        fwd_largest_time = t1 - t0

        # Run Adaptive A*
        t0 = time.time()
        adaptive_search, adaptive_search_exp = adaptive.adaptive_a_star(start, goal, maze_list, -1)
        t1 = time.time()
        adp_time = t1 - t0
        
        status = "OK"
        if isinstance(forward_largest_g, str) or isinstance(adaptive_search, str):
            status = "Fail"
        elif len(forward_largest_g) != len(adaptive_search):
             # Path lengths might differ if one finds optimal and other doesn't? 
             # Repeated A* on static grid should find optimal if A* is optimal?
             # Actually Repeated A* with unobserved obstacles is not guaranteed optimal path *traversal* cost,
             # but the final path on the map... wait.
             # The implementations return the path taken.
             # They might differ.
             if abs(len(forward_largest_g) - len(adaptive_search)) > 0:
                 status = f"Start:{start} | End:{goal} | Path Fwd:{len(forward_largest_g)} | Path Adp:{len(adaptive_search)}"

        results.append({
            "Maze": maze_name,
            "Fwd_Search": forward_largest_g_exp,
            "Adp_Search": adaptive_search_exp,
            "Fwd_time": fwd_largest_time,
            "Adp_time": adp_time
        })

        print(f"{maze_name:<10} | {forward_largest_g_exp:<27} | {adaptive_search_exp:<29} | {fwd_largest_time:<12.4f} | {adp_time:<13.4f} | {status}")

    # Calculate averages
    avg_fwd = sum(r["Fwd_Search"] for r in results) / num_mazes
    avg_adp = sum(r["Adp_Search"] for r in results) / num_mazes
    avg_fwd_time = sum(r["Fwd_time"] for r in results) / num_mazes
    avg_adp_time = sum(r["Adp_time"] for r in results) / num_mazes
    
    print("-" * 112)
    print(f"{'Average':<10} | {avg_fwd:<27.4f} | {avg_adp:<29.4f} | {avg_fwd_time:<12.4f} | {avg_adp_time:<13.4f} |")

    #Calculate how better prioritizing by large is in terms of % improvement
    adp_cell_improvement = (avg_adp_time - avg_fwd_time)/avg_fwd_time
    adp_time_improvement = (avg_adp_time - avg_fwd_time)/avg_fwd_time
    #% shown will be negative, which means a reduction in time (good)
    print(f"{'% Improved':<10} | {'-':<27} | {adp_cell_improvement:<29.4f} | {'-':<12} | {adp_time_improvement:<13.4f} |")